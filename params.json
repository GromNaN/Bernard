{"name":"Raekke","tagline":"Message queue implemented with Redis and PHP.","body":"Raekke\r\n======\r\n\r\nRaekke is a message queue implemented in php. It is very similiar to Resque and\r\nallows for easy creation of workers and creating distributed systems.\r\n\r\n[![Build Status](https://travis-ci.org/henrikbjorn/Raekke.png?branch=master)](https://travis-ci.org/henrikbjorn/Raekke)\r\n\r\nGetting Started\r\n---------------\r\n\r\nRaekke allows you as Resque to create messages and place them on a queue. And\r\nlater on pull thoose off the queue and process them. It is not a a complete\r\nsolution to have any object method being called at a later time (as resque).\r\n\r\n### Installing\r\n\r\nThe easiest way to install Raekke is by using [Composer](http://getcomposer.org).\r\nIf your projects do not already use this, it is highly recommended to start.\r\n\r\n``` bash\r\n$ composer require henrikbjorn/raekke:dev-master\r\n```\r\n\r\n### Configuring Predis\r\n\r\nFor storing messages Redis is used together with Predis as the communication\r\ndriver between php and Redis. This means Predis and Redis is required.\r\n\r\nIt is highly encourage to use a prefix for Predis (but not enforces) to make\r\nsure your sets does not conflict with others of the same same.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Raekke\\Connection;\r\nuse Predis\\Client;\r\n\r\n$predis = new Client('tcp://localhost', array(\r\n    'prefix' => 'raekke:',\r\n));\r\n\r\n$connection = new Connection($predis);\r\n```\r\n\r\n### Sending Messages\r\n\r\nAny message sent to Raekke must be an instance of `Raekke\\Message\\MessageInterface`\r\nwhich have a `getName` and `getQueue` method. `getName` is used when working on\r\nmessages and identifies the worker service that should work on it.\r\n\r\nA message is given to a publisher that send the message to the right queue.\r\nIt is also possible to get the queue directly from the queue factory and push\r\nthe message there. But remember to wrap the message in a `MessageWrapper` object.\r\nThe easiest is to give it to the publisher as the queue name\r\nis taken from the message object.\r\n\r\nTo make it easier to send messages and not require every type to be implemented\r\nin a seperate class a `Raekke\\Message\\DefaultMessage` is provided. It can hold\r\nany number of proberties and only needs a name for the message. The queue name\r\nis then generated from that. When generating the queue name it will insert a \"_\"\r\nbefore any uppercase letters and then lowercase everything.\r\n\r\nMessages are serialized to json using [JMS Serializer](http://jmsyst.com/libs/serializer).\r\nTherefor an instance of that is required. Also if custom message classes are\r\nused it is needed to add metadata for being able to serialize and deserialize them.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Raekke\\MessagePublisher;\r\nuse Raekke\\Message\\DefaultMessage;\r\nuse Raekke\\Message\\MessageWrapper;\r\nuse Raekke\\QueueFactory;\r\nuse Raekke\\Serializer\\Serializer;\r\n\r\n// .. create serializer instance where src/Raekke/Resources/serializer\r\n// is registered as a metadata dir with \"Raekke\" as prefix.\r\n$serializer = new Serializer($jmsSerializer);\r\n\r\n// .. create connection\r\n$factory = new QueueFactory($connection, $serializer);\r\n$publisher = new MessagePublisher($factory);\r\n\r\n$message = new DefaultMessage(\"SendNewsletter\", array(\r\n    'newsletterId' => 12,\r\n));\r\n\r\n$publisher->publish($message);\r\n\r\n// or give it to a queue directly\r\n$factory->get('my-queue')->enqueue(new MessageWrapper($message));\r\n```\r\n\r\n### Working on Messages\r\n\r\nA single message represents a job that needs to be performed. And as described\r\nearlier a message's name is used to determaine what worker should have that\r\nmessage. For that a worker manager is needed.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Raekke\\WorkerManager;\r\n\r\n// create a $queueManager instance.\r\n\r\n$workerManager = new WorkerManager($queueManager);\r\n```\r\n\r\nThe worker manager also needs to know what workers it can send messages to.\r\nA worker is a server class. If it is an object and the worker is registered to\r\n`SendNewsletter` the manager will call the method `$workerService->onSendNewsletter`.\r\nThis allows for a single service class to handle more than one message.\r\n\r\n``` php\r\n<?php\r\n\r\nclass NewsletterWorker\r\n{\r\n    public function onSendNewsletter(DefaultMessage $message)\r\n    {\r\n        // Do some work on DefaultMessage here.\r\n    }\r\n}\r\n\r\n$workerManager->register('SendNewsletter', new NewsletterWorker);\r\n\r\n// or register multiple services at once.\r\n$workerManager->registerServices(array(\r\n    'SendNewsletter' => new NewsletterWorker(),\r\n));\r\n```\r\n\r\nThe worker manager would normally be abstracted out and populated by a container\r\nof some sort like the [Symfony Dependency Injection](http://symfony.com/doc/current/components/dependency_injection).\r\n\r\nAnyone who have created a deamon in php and tried handling signal's they know\r\nit is hard. Therefor Raekke comes with a worker command for [Symfony Console](http://symfony.com/doc/current/components/console)\r\ncomponent. The command should be added to your console application.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Raekke\\Command\\WorkerCommand;\r\n\r\n// .. create an instance of Symfony\\Console\\Application as $app\r\n// .. create a Raekke\\WorkerManager as $workerManager\r\n$app->add(new WorkerCommand($workerManager));\r\n```\r\n\r\nIt can then be used as any other console command. The argument given should be\r\nthe queue that your messages is on. If we use the earlier example with sending\r\nnewsletter it would look like this.\r\n\r\n``` bash\r\n$ /path/to/console raekke:worker --interval=10 'send-newsletter'\r\n```\r\n\r\n`--interval` is the time it will wait for a single message to be returned from\r\nthe backend before assuming null and it being empty it defaults to 5 and is\r\noptional.\r\n\r\nIntegration with Frameworks\r\n---------------------------\r\n\r\nTo make it easier to start up and have it \"just work\" with sending messages a\r\nnumber of integrations have been created.\r\n\r\n* Somebody should do this part...\r\n\r\nMonitoring\r\n----------\r\n\r\nHaving a message queue where it is not possible to what whats in queue and the\r\ncontents of the messages is not very handy. And for that there is [Juno](https://github.com/henrikbjorn/Juno).\r\n\r\nIt is implemented in Silex and is very lightweight. Also if needed it can be\r\nembedded in other Silex or Flint applications.\r\n\r\n![Juno](http://i.imgur.com/oZFzfKq.png)\r\n\r\nAlternatives\r\n------------\r\n\r\nIf this is not your cup of tea there exists other alternatives that might be\r\nbetter for your needs.\r\n\r\n* [php-resque](https://github.com/chrisboulton/php-resque)\r\n* [Resque](https://github.com/defunkt/resque)\r\n\r\n\r\nHappy Customers\r\n---------------\r\n\r\nNot really anybody as it is not completly finished. If you need something like\r\nthis i encourage you to contact me and we will figure out how we can work\r\ntogether on this.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}