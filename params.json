{"name":"Bernard","tagline":"Message queue implemented with Redis and PHP.","body":"Bernard\r\n======\r\n\r\nBernard is a message queue implemented in php. It is very similiar to Resque and\r\nallows for easy creation of workers and creating distributed systems.\r\n\r\n[![Build Status](https://travis-ci.org/henrikbjorn/Bernard.png?branch=master)](https://travis-ci.org/henrikbjorn/Bernard)\r\n\r\nGetting Started\r\n---------------\r\n\r\nBernard allows you as Resque to create messages and place them on a queue. And\r\nlater on pull thoose off the queue and process them. It is not a a complete\r\nsolution to have any object method being called at a later time (as resque).\r\n\r\n### Installing\r\n\r\nThe easiest way to install Bernard is by using [Composer](http://getcomposer.org).\r\nIf your projects do not already use this, it is highly recommended to start.\r\n\r\n``` bash\r\n$ composer require henrikbjorn/bernard:dev-master\r\n```\r\n\r\n### Examples\r\n\r\nIn the `example` directory there are two examples of running Bernard. `producer.php` will\r\nconnect to redis on localhost and produce `EchoTime` messages. `consumer.php` will consume\r\ntheese and print the timestamp.\r\n\r\n`in_memory.php` will produce 20 `EchoTime` messages and consume them right they\r\nhave been sent. It uses `SplQueue` and does not need a redis backend.\r\n\r\n### Configuring Predis\r\n\r\nFor storing messages Redis is used together with Predis as the communication\r\ndriver between php and Redis. This means Predis and Redis is required.\r\n\r\nIt is highly encourage to use a prefix for Predis (but not enforces) to make\r\nsure your sets does not conflict with others of the same same.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Bernard\\Connection\\PredisConnection;\r\nuse Predis\\Client;\r\n\r\n$predis = new Client('tcp://localhost', array(\r\n    'prefix' => 'bernard:',\r\n));\r\n\r\n$connection = new PredisConnection($predis);\r\n```\r\n\r\n### Producing Messages\r\n\r\nAny message sent to Bernard must be an instance of `Bernard\\Message`\r\nwhich have a `getName` and `getQueue` method. `getName` is used when working on\r\nmessages and identifies the worker service that should work on it.\r\n\r\nA message is given to a producer that send the message to the right queue.\r\nIt is also possible to get the queue directly from the queue factory and push\r\nthe message there. But remember to wrap the message in a `Envelope` object.\r\nThe easiest is to give it to the producer as the queue name\r\nis taken from the message object.\r\n\r\nTo make it easier to send messages and not require every type to be implemented\r\nin a seperate class a `Bernard\\Message\\DefaultMessage` is provided. It can hold\r\nany number of proberties and only needs a name for the message. The queue name\r\nis then generated from that. When generating the queue name it will insert a \"_\"\r\nbefore any uppercase letters and then lowercase everything.\r\n\r\nMessages are serialized to json using [JMS Serializer](http://jmsyst.com/libs/serializer).\r\nTherefor an instance of that is required. Also if custom message classes are\r\nused it is needed to add metadata for being able to serialize and deserialize them.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Bernard\\Message\\DefaultMessage;\r\nuse Bernard\\Message\\Envelope;\r\nuse Bernard\\Producer;\r\nuse Bernard\\QueueFactory\\PersistentFactory;\r\nuse Bernard\\Serializer\\JMSSerializer;\r\n\r\n// .. create serializer instance where src/Bernard/Resources/serializer\r\n// is registered as a metadata dir with \"Bernard\" as prefix.\r\n$serializer = new JMSSerializer($jmsSerializer);\r\n\r\n// .. create connection\r\n$factory = new PersistentFactory($connection, $serializer);\r\n$producer = new Producer($factory);\r\n\r\n$message = new DefaultMessage(\"SendNewsletter\", array(\r\n    'newsletterId' => 12,\r\n));\r\n\r\n$producer->publish($message);\r\n\r\n// or give it to a queue directly\r\n$factory->get('my-queue')->enqueue(new Envelope($message));\r\n```\r\n\r\n#### In Memory Queues\r\n\r\nBernard comes with a implemention for `SplQueue` which is completly in memory\r\nIt is useful for development and/or testing. As you dont want actions to be\r\nperformed.\r\n\r\n### Consuming Messages\r\n\r\nA single message represents a job that needs to be performed. And as described\r\nearlier a message's name is used to determaine what service object should have\r\nthat message.\r\n\r\nA service object can be any object that have a method corresponding to the message\r\nname prefixed with on. So `new DefaultMessage('SendNewsletter')` will trigger a\r\ncall to `$serviceObject->onSendNewsletter`. For the system to know what service\r\nobject should handle what messages it is need to register them first.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Bernard\\ServiceResolver\\ObjectResolver;\r\nuse Bernard\\Consumer;\r\n\r\n// .. create connection and a queuefactory\r\n// NewsletterMessageHandler is a pseudo service object that responds to\r\n// onSendNewsletter.\r\n\r\n$serviceResolver = new ObjectResolver;\r\n$serviceResolver->register('SendNewsletter', new NewsletterMessageHandler);\r\n\r\n// Bernard also comes with a service resolver for Pimple (Silex) which allows you\r\n// to use service ids and have your service object lazy loader.\r\n//\r\n// $serviceResolver = new \\Bernard\\Pimple\\PimpleAwareResolver($pimple);\r\n// $serviceResolver->register('SendNewsletter', 'my.service.id');\r\n//\r\n// Symfony DependencyInjection component is also supported.\r\n//\r\n// $serviceResolver = new \\Bernard\\Symfony\\ContainerAwareServiceResolver($container);\r\n// $serviceResolver->register('SendNewsletter', 'my.service.id');\r\n\r\n// Create a Consumer and start the loop. The second argument is optional and\r\n// is the queue failed messages should be added to.\r\n$consumer = new Consumer($serviceResolver, $queueFactory->create('failed'));\r\n$consumer->consume($queueFactory->create('send-newsletter'));\r\n```\r\n\r\nBernard comes with a `ConsumeCommand` which can be used with Symfony Console \r\ncomponent.\r\n\r\n``` php\r\n<?php\r\n\r\nuse Bernard\\Command\\ConsumeCommand;\r\n\r\n// create $console application\r\n$console->add(new ConsumeCommand($services, $queueManager));\r\n```\r\n\r\nIt can then be used as any other console command. The argument given should be\r\nthe queue that your messages is on. If we use the earlier example with sending\r\nnewsletter it would look like this.\r\n\r\n``` bash\r\n$ /path/to/console bernard:consume 'send-newsletter'\r\n```\r\n\r\nIntegration with Frameworks\r\n---------------------------\r\n\r\nTo make it easier to start up and have it \"just work\" with sending messages a\r\nnumber of integrations have been created.\r\n\r\n* __Silex__: [BernardServiceProvider](https://github.com/henrikbjorn/BernardServiceProvider)\r\n\r\nMonitoring\r\n----------\r\n\r\nHaving a message queue where it is not possible to what whats in queue and the\r\ncontents of the messages is not very handy. And for that there is [Juno](https://github.com/henrikbjorn/Juno).\r\n\r\nIt is implemented in Silex and is very lightweight. Also if needed it can be\r\nembedded in other Silex or Flint applications.\r\n\r\nAlternatives\r\n------------\r\n\r\nIf this is not your cup of tea there exists other alternatives that might be\r\nbetter for your needs.\r\n\r\n* [php-resque](https://github.com/chrisboulton/php-resque)\r\n* [Resque](https://github.com/defunkt/resque)\r\n\r\nSpecial Thanks\r\n--------------\r\n\r\n* [Igor Wiedler](http://igor.io) and [Dave Marshall](http://davedevelopment.co.uk) for helping me find a better name\r\nthan Raekke.\r\n* [Benjamin Eberlei](http://whitewashing.de) for advice regarding architeture\r\n* [Peytz & Co](http://peytz.dk)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}