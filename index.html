<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Bernard by henrikbjorn</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Bernard</h1>
        <p>Message queue implemented with Redis and PHP.</p>

        <p class="view"><a href="https://github.com/henrikbjorn/Bernard">View the Project on GitHub <small>henrikbjorn/Bernard</small></a></p>


        <ul>
          <li><a href="https://github.com/henrikbjorn/Bernard/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/henrikbjorn/Bernard/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/henrikbjorn/Bernard">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>Bernard</h1>

<p>Bernard is a message queue implemented in php. It is very similiar to Resque and
allows for easy creation of workers and creating distributed systems.</p>

<p><a href="https://travis-ci.org/henrikbjorn/Bernard"><img src="https://travis-ci.org/henrikbjorn/Bernard.png?branch=master" alt="Build Status"></a></p>

<h2>Getting Started</h2>

<p>Bernard allows you as Resque to create messages and place them on a queue, and
later on pull those off the queue and process them. It is not a complete
solution to have any object method being called at a later time (as resque).</p>

<h3>Installing</h3>

<p>The easiest way to install Bernard is by using <a href="http://getcomposer.org">Composer</a>.
If your projects do not already use this, it is highly recommended to start.</p>

<div class="highlight"><pre><span class="nv">$ </span>composer require henrikbjorn/bernard:dev-master
</pre></div>

<h3>Examples</h3>

<p>In the <code>example</code> directory there are two examples of running Bernard. <code>producer.php</code> will
connect to redis on localhost and produce <code>EchoTime</code> messages. <code>consumer.php</code> will consume
theese and print the timestamp.</p>

<p><code>in_memory.php</code> will produce 20 <code>EchoTime</code> messages and consume them right they
have been sent. It uses <code>SplQueue</code> and does not need a redis backend.</p>

<h3>Configuring Predis</h3>

<p>For storing messages Redis is used together with Predis as the communication
driver between php and Redis. This means Predis and Redis is required.</p>

<p>It is highly encouraged to use a prefix for Predis (but not enforced) to make
sure your sets do not conflict with others of the same name.</p>

<div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span>

<span class="k">use</span> <span class="nx">Bernard\Connection\PredisConnection</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Predis\Client</span><span class="p">;</span>

<span class="nv">$predis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Client</span><span class="p">(</span><span class="s1">'tcp://localhost'</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">'prefix'</span> <span class="o">=&gt;</span> <span class="s1">'bernard:'</span><span class="p">,</span>
<span class="p">));</span>

<span class="nv">$connection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PredisConnection</span><span class="p">(</span><span class="nv">$predis</span><span class="p">);</span>
</pre></div>

<h3>Producing Messages</h3>

<p>Any message sent to Bernard must be an instance of <code>Bernard\Message</code>
which have a <code>getName</code> and <code>getQueue</code> method. <code>getName</code> is used when working on
messages and identifies the worker service that should work on it.</p>

<p>A message is given to a producer that sends the message to the right queue.
It is also possible to get the queue directly from the queue factory and push
the message there. But remember to wrap the message in an <code>Envelope</code> object.
The easiest way is to give it to the producer as the queue name
is taken from the message object.</p>

<p>To make it easier to send messages and not require every type to be implemented
in a seperate class, a <code>Bernard\Message\DefaultMessage</code> is provided. It can hold
any number of proberties and only needs a name for the message. The queue name
is then generated from that. When generating the queue name it will insert a "_"
before any uppercase letters and then lowercase everything.</p>

<p>Messages are serialized to json using <a href="http://jmsyst.com/libs/serializer">JMS Serializer</a>.
Therefore an instance of that is required. Also if custom message classes are
used it is needed to add metadata for being able to serialize and deserialize them.</p>

<div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span>

<span class="k">use</span> <span class="nx">Bernard\Message\DefaultMessage</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Bernard\Message\Envelope</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Bernard\Producer</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Bernard\QueueFactory\PersistentFactory</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Bernard\Serializer\JMSSerializer</span><span class="p">;</span>

<span class="c1">// .. create serializer instance where src/Bernard/Resources/serializer</span>
<span class="c1">// is registered as a metadata dir with "Bernard" as prefix.</span>
<span class="nv">$serializer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JMSSerializer</span><span class="p">(</span><span class="nv">$jmsSerializer</span><span class="p">);</span>

<span class="c1">// .. create connection</span>
<span class="nv">$factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PersistentFactory</span><span class="p">(</span><span class="nv">$connection</span><span class="p">,</span> <span class="nv">$serializer</span><span class="p">);</span>
<span class="nv">$producer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Producer</span><span class="p">(</span><span class="nv">$factory</span><span class="p">);</span>

<span class="nv">$message</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DefaultMessage</span><span class="p">(</span><span class="s2">"SendNewsletter"</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">'newsletterId'</span> <span class="o">=&gt;</span> <span class="mi">12</span><span class="p">,</span>
<span class="p">));</span>

<span class="nv">$producer</span><span class="o">-&gt;</span><span class="na">publish</span><span class="p">(</span><span class="nv">$message</span><span class="p">);</span>

<span class="c1">// or give it to a queue directly</span>
<span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'my-queue'</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">enqueue</span><span class="p">(</span><span class="k">new</span> <span class="nx">Envelope</span><span class="p">(</span><span class="nv">$message</span><span class="p">));</span>
</pre></div>

<h4>In Memory Queues</h4>

<p>Bernard comes with an implemention for <code>SplQueue</code> which is completly in memory.
It is useful for development and/or testing, when you don't necessarily want actions to be
performed.</p>

<h3>Consuming Messages</h3>

<p>A single message represents a job that needs to be performed, and as described
earlier, a message's name is used to determine which service object should
receive that message.</p>

<p>A service object can be any object that has a method corresponding to the message
name prefixed with <code>on</code>. So <code>new DefaultMessage('SendNewsletter')</code> will trigger a
call to <code>$serviceObject-&gt;onSendNewsletter</code>. For the system to know which service
object should handle which messages, your are required to register them first.</p>

<div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span>

<span class="k">use</span> <span class="nx">Bernard\ServiceResolver\ObjectResolver</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Bernard\Consumer</span><span class="p">;</span>

<span class="c1">// .. create connection and a queuefactory</span>
<span class="c1">// NewsletterMessageHandler is a pseudo service object that responds to</span>
<span class="c1">// onSendNewsletter.</span>

<span class="nv">$serviceResolver</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ObjectResolver</span><span class="p">;</span>
<span class="nv">$serviceResolver</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">'SendNewsletter'</span><span class="p">,</span> <span class="k">new</span> <span class="nx">NewsletterMessageHandler</span><span class="p">);</span>

<span class="c1">// Bernard also comes with a service resolver for Pimple (Silex) which allows you</span>
<span class="c1">// to use service ids and have your service object lazy loader.</span>
<span class="c1">//</span>
<span class="c1">// $serviceResolver = new \Bernard\Pimple\PimpleAwareResolver($pimple);</span>
<span class="c1">// $serviceResolver-&gt;register('SendNewsletter', 'my.service.id');</span>
<span class="c1">//</span>
<span class="c1">// Symfony DependencyInjection component is also supported.</span>
<span class="c1">//</span>
<span class="c1">// $serviceResolver = new \Bernard\Symfony\ContainerAwareServiceResolver($container);</span>
<span class="c1">// $serviceResolver-&gt;register('SendNewsletter', 'my.service.id');</span>

<span class="c1">// Create a Consumer and start the loop. The second argument is optional and</span>
<span class="c1">// is the queue failed messages should be added to.</span>
<span class="nv">$consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Consumer</span><span class="p">(</span><span class="nv">$serviceResolver</span><span class="p">,</span> <span class="nv">$queueFactory</span><span class="o">-&gt;</span><span class="na">create</span><span class="p">(</span><span class="s1">'failed'</span><span class="p">));</span>
<span class="nv">$consumer</span><span class="o">-&gt;</span><span class="na">consume</span><span class="p">(</span><span class="nv">$queueFactory</span><span class="o">-&gt;</span><span class="na">create</span><span class="p">(</span><span class="s1">'send-newsletter'</span><span class="p">));</span>
</pre></div>

<p>Bernard comes with a <code>ConsumeCommand</code> which can be used with Symfony Console 
component.</p>

<div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span>

<span class="k">use</span> <span class="nx">Bernard\Command\ConsumeCommand</span><span class="p">;</span>

<span class="c1">// create $console application</span>
<span class="nv">$console</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="nx">ConsumeCommand</span><span class="p">(</span><span class="nv">$services</span><span class="p">,</span> <span class="nv">$queueManager</span><span class="p">));</span>
</pre></div>

<p>It can then be used as any other console command. The argument given should be
the queue that your messages are on. If we use the earlier example with sending
a newsletter, it would look like this.</p>

<div class="highlight"><pre><span class="nv">$ </span>/path/to/console bernard:consume <span class="s1">'send-newsletter'</span>
</pre></div>

<h2>Integration with Frameworks</h2>

<p>To make it easier to get started and have it "just work" with sending messages,
a number of integrations have been created.</p>

<ul>
<li>
<strong>Silex</strong>: <a href="https://github.com/henrikbjorn/BernardServiceProvider">BernardServiceProvider</a>
</li>
</ul><h2>Monitoring</h2>

<p>Having a message queue where it is not possible to know what is in the queue and the
contents of the messages is not very handy, so for that there is <a href="https://github.com/henrikbjorn/Juno">Juno</a>.</p>

<p>It is implemented in Silex and is very lightweight. Also if needed, it can be
embedded in other Silex or Flint applications.</p>

<h2>Alternatives</h2>

<p>If this is not your cup of tea there are other alternatives that might be
better suited to your needs.</p>

<ul>
<li><a href="https://github.com/chrisboulton/php-resque">php-resque</a></li>
<li><a href="https://github.com/defunkt/resque">Resque</a></li>
</ul><h2>Special Thanks</h2>

<ul>
<li>
<a href="http://igor.io">Igor Wiedler</a> and <a href="http://davedevelopment.co.uk">Dave Marshall</a> for helping me find a better name
than Raekke.</li>
<li>
<a href="http://whitewashing.de">Benjamin Eberlei</a> for advice regarding architeture</li>
<li><a href="http://peytz.dk">Peytz &amp; Co</a></li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/henrikbjorn">henrikbjorn</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>